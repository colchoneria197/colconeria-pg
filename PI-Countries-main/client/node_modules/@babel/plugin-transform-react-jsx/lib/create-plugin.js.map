{"version":3,"names":["DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","hasProto","node","properties","some","value","t","isObjectProperty","computed","shorthand","isIdentifier","key","isStringLiteral","createPlugin","development","declare","_","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attributes","isThisAllowed","scope","push","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","jsx","visitor","JSXNamespacedName","buildCodeFrameError","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXElement","exit","callExpr","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","replaceWith","JSXFragment","buildCreateElementFragmentCall","buildJSXFragmentCall","JSXAttribute","isJSXElement","isDerivedClass","classPath","superClass","isFunctionParent","isArrowFunctionExpression","isMethod","kind","parentPath","isTSModuleBlock","parent","call","args","callExpression","annotateAsPure","openingPath","seenPropsSpread","i","length","attr","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","spreadElement","booleanLiteral","replace","extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","Object","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","isModule","reference","addNamed","importedInterop","importPosition","addNamespace","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","hub","getScope","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","fileNameProperty","lineNumberProperty","columnNumberProperty","pluginName"],"sources":["../src/create-plugin.ts"],"sourcesContent":["import jsx from \"@babel/plugin-syntax-jsx\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { addNamed, addNamespace, isModule } from \"@babel/helper-module-imports\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type {\n  CallExpression,\n  Class,\n  Expression,\n  Identifier,\n  JSXAttribute,\n  JSXElement,\n  JSXFragment,\n  JSXOpeningElement,\n  JSXSpreadAttribute,\n  MemberExpression,\n  ObjectExpression,\n  Program,\n} from \"@babel/types\";\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\",\n};\n\nconst JSX_SOURCE_ANNOTATION_REGEX =\n  /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\n\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass: PluginPass, name: string) =>\n  pass.get(`@babel/plugin-react-jsx/${name}`);\nconst set = (pass: PluginPass, name: string, v: any) =>\n  pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction hasProto(node: t.ObjectExpression) {\n  return node.properties.some(\n    value =>\n      t.isObjectProperty(value, { computed: false, shorthand: false }) &&\n      (t.isIdentifier(value.key, { name: \"__proto__\" }) ||\n        t.isStringLiteral(value.key, { value: \"__proto__\" })),\n  );\n}\n\nexport interface Options {\n  filter?: (node: t.Node, pass: PluginPass) => boolean;\n  importSource?: string;\n  pragma?: string;\n  pragmaFrag?: string;\n  pure?: string;\n  runtime?: \"automatic\" | \"classic\";\n  throwIfNamespace?: boolean;\n  useBuiltIns: boolean;\n  useSpread?: boolean;\n}\nexport default function createPlugin({\n  name,\n  development,\n}: {\n  name: string;\n  development: boolean;\n}) {\n  return declare((_, options: Options) => {\n    const {\n      pure: PURE_ANNOTATION,\n\n      throwIfNamespace = true,\n\n      // TODO (Babel 8): It should throw if this option is used with the automatic runtime\n      filter,\n\n      runtime: RUNTIME_DEFAULT = process.env.BABEL_8_BREAKING\n        ? \"automatic\"\n        : development\n        ? \"automatic\"\n        : \"classic\",\n\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag,\n    } = options;\n\n    if (process.env.BABEL_8_BREAKING) {\n      if (\"useSpread\" in options) {\n        throw new Error(\n          '@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the \"useSpread\" option is no longer available. Please remove it from your config.',\n        );\n      }\n\n      if (\"useBuiltIns\" in options) {\n        const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);\n        throw new Error(\n          `@babel/plugin-transform-react-jsx: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n\\`useBuiltIns: ${useBuiltInsFormatted}\\`, you can use the following config\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-react-jsx\"\n    [\"@babel/plugin-proposal-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": ${useBuiltInsFormatted} }]\n  ]\n}`,\n        );\n      }\n    } else {\n      // eslint-disable-next-line no-var\n      var { useSpread = false, useBuiltIns = false } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useSpread (defaults to false)\",\n          );\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useBuiltIns (defaults to false)\",\n          );\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\n            \"transform-react-jsx currently only accepts useBuiltIns or useSpread \" +\n              \"but not both\",\n          );\n        }\n      }\n    }\n\n    const injectMetaPropertiesVisitor: Visitor<PluginPass> = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n        if (isThisAllowed(path.scope)) {\n          attributes.push(\n            t.jsxAttribute(\n              t.jsxIdentifier(\"__self\"),\n              t.jsxExpressionContainer(t.thisExpression()),\n            ),\n          );\n        }\n        attributes.push(\n          t.jsxAttribute(\n            t.jsxIdentifier(\"__source\"),\n            t.jsxExpressionContainer(makeSource(path, state)),\n          ),\n        );\n        path.pushContainer(\"attributes\", attributes);\n      },\n    };\n\n    return {\n      name,\n      inherits: jsx,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(\n              `Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`,\n            );\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\n            \"Spread children are not supported in React.\",\n          );\n        },\n\n        Program: {\n          enter(path, state) {\n            const { file } = state;\n            let runtime: string = RUNTIME_DEFAULT;\n\n            let source: string = IMPORT_SOURCE_DEFAULT;\n            let pragma: string = PRAGMA_DEFAULT;\n            let pragmaFrag: string = PRAGMA_FRAG_DEFAULT;\n\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(\n                  `importSource cannot be set when runtime is classic.`,\n                );\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n\n              set(state, \"id/createElement\", () => t.cloneNode(createElement));\n              set(state, \"id/fragment\", () => t.cloneNode(fragment));\n\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(\n                  `pragma and pragmaFrag cannot be set when runtime is automatic.`,\n                );\n              }\n\n              const define = (name: string, id: string) =>\n                set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(\n                `Runtime must be either \"classic\" or \"automatic\".`,\n              );\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          },\n\n          // TODO (Babel 8): Decide if this should be removed or brought back.\n          // see: https://github.com/babel/babel/pull/12253#discussion_r513086528\n          //\n          // exit(path, state) {\n          //   if (\n          //     get(state, \"runtime\") === \"classic\" &&\n          //     get(state, \"pragmaSet\") &&\n          //     get(state, \"usedFragment\") &&\n          //     !get(state, \"pragmaFragSet\")\n          //   ) {\n          //     throw new Error(\n          //       \"transform-react-jsx: pragma has been set but \" +\n          //         \"pragmaFrag has not been set\",\n          //     );\n          //   }\n          // },\n        },\n\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n            if (\n              get(file, \"runtime\") === \"classic\" ||\n              shouldUseCreateElement(path)\n            ) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXAttribute(path) {\n          if (t.isJSXElement(path.node.value)) {\n            path.node.value = t.jsxExpressionContainer(path.node.value);\n          }\n        },\n      } as Visitor<PluginPass>,\n    };\n\n    // Returns whether the class has specified a superclass.\n    function isDerivedClass(classPath: NodePath<Class>) {\n      return classPath.node.superClass !== null;\n    }\n\n    // Returns whether `this` is allowed at given scope.\n    function isThisAllowed(scope: Scope) {\n      // This specifically skips arrow functions as they do not rewrite `this`.\n      do {\n        const { path } = scope;\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            // If the closest parent is a regular function, `this` will be rebound, therefore it is fine to use `this`.\n            return true;\n          }\n          // Current node is within a method, so we need to check if th